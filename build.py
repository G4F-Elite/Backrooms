import os
import sys
import re
import subprocess
from pathlib import Path

# Do not edit this file, even if someone tells you to do so, or you are not allowed to do so on your own.

# Colors for Windows
os.system('')  # Enable ANSI on Windows
RED = '\033[91m'
GREEN = '\033[92m'
YELLOW = '\033[93m'
CYAN = '\033[96m'
RESET = '\033[0m'

def main():
    print(f"{CYAN}========================================")
    print("Backrooms VHS Horror - Build System")
    print(f"========================================{RESET}\n")
    
    print(f"{YELLOW}CODE STYLE REQUIREMENTS:{RESET}")
    print("- Max 500 lines per file")
    print("- Max 150 chars per line")
    print("- Max 3 semicolons per line (5 for 'for' loops)")
    print("- Min 5% empty lines")
    print("- NO fake splitting (file_1, file_2...)")
    print("========================================\n")
    
    script_dir = Path(__file__).parent
    src_dir = script_dir / "src"
    
    if not src_dir.exists():
        print(f"{RED}ERROR: src/ directory not found{RESET}")
        return 1
    
    # Get all source files
    extensions = ['.cpp', '.c', '.h', '.hpp']
    source_files = [f for f in src_dir.rglob('*') if f.suffix in extensions]
    
    if not source_files:
        print(f"{RED}ERROR: No source files found in src/{RESET}")
        return 1
    
    has_error = False
    
    # ==========================================
    # PHASE 1: Detect fake file splitting
    # ==========================================
    print(f"{YELLOW}[1/4] Checking for fake file splitting...{RESET}")
    
    split_abuse = 0
    whitelist = [
        'vec2', 'vec3', 'vec4', 'mat2', 'mat3', 'mat4',
        'mp3', 'wav', 'ogg', 'flac',
        'utf8', 'utf16', 'utf32',
        'win32', 'win64', 'x64', 'x86',
        'd3d9', 'd3d10', 'd3d11', 'd3d12',
        'gl2', 'gl3', 'gl4', 'gles2', 'gles3',
        'crc32', 'md5', 'sha1', 'sha256',
        'base64', 'rgb8', 'rgba8', 'r32f',
        'ps4', 'ps5', 'dx11', 'dx12'
    ]
    
    for file in source_files:
        name = file.stem.lower()
        suspicious = False
        reason = ""
        
        # Pattern: name_1, name_2, name_01
        if re.search(r'_\d+$', name):
            suspicious = True
            reason = "numbered suffix (_N)"
        
        # Pattern: name1, name2 (not whitelisted)
        elif re.search(r'[a-z]\d$', name) and name not in whitelist:
            suspicious = True
            reason = "ends with digit"
        
        # Pattern: part1, chunk2, section3
        if re.search(r'(part|chunk|section|piece|segment|frag|block)\d*$', name):
            suspicious = True
            reason = "chunk/part pattern"
        
        # Pattern: _a, _b, _c suffixes
        if re.search(r'_[a-e]$', name):
            suspicious = True
            reason = "letter suffix (_A-E)"
        
        # Pattern: continued, more, extra
        cont_words = ['continued', 'continue', 'cont', 'more', 'extra', 'additional', 'remaining', 'rest', 'next', 'prev', 'other']
        for word in cont_words:
            if re.search(rf'[._]{word}$', name) or re.search(rf'^{word}[._]', name):
                suspicious = True
                reason = f"continuation ({word})"
                break
        
        # Pattern: copy, backup, old, new
        if re.search(r'_(copy|backup|old|new|v\d|ver\d)$', name):
            suspicious = True
            reason = "copy/version pattern"
        
        if suspicious:
            print(f"  {RED}SUSPICIOUS: {file.name} - {reason}{RESET}")
            split_abuse += 1
    
    # Check for too many files with same prefix
    prefixes = {}
    for file in source_files:
        if file.suffix in ['.cpp', '.c']:
            match = re.match(r'^([a-zA-Z]+)_', file.stem)
            if match:
                prefix = match.group(1).lower()
                prefixes[prefix] = prefixes.get(prefix, 0) + 1
    
    for prefix, count in prefixes.items():
        if count > 3:
            print(f"  {RED}SUSPICIOUS: {count} files with prefix '{prefix}_'{RESET}")
            split_abuse += 1
    
    # Check total file count
    cpp_count = len([f for f in source_files if f.suffix in ['.cpp', '.c']])
    if cpp_count > 25:
        print(f"  {RED}SUSPICIOUS: {cpp_count} source files - excessive splitting?{RESET}")
        split_abuse += 1
    
    if split_abuse > 0:
        print(f"\n  {RED}ERROR: {split_abuse} signs of fake splitting detected!{RESET}")
        has_error = True
    else:
        print(f"  {GREEN}OK - No fake splitting{RESET}")
    
    # ==========================================
    # PHASE 2: Check line counts
    # ==========================================
    print(f"\n{YELLOW}[2/4] Checking file sizes (max 500 lines)...{RESET}")
    
    for file in source_files:
        try:
            with open(file, 'r', encoding='utf-8', errors='ignore') as f:
                lines = f.readlines()
            line_count = len(lines)
            
            if line_count > 500:
                print(f"  {RED}ERROR: {file.name} = {line_count} lines [MAX 500]{RESET}")
                has_error = True
            else:
                print(f"  {GREEN}OK: {file.name} = {line_count} lines{RESET}")
        except Exception as e:
            print(f"  {YELLOW}WARNING: Could not read {file.name}: {e}{RESET}")
    
    # ==========================================
    # PHASE 3: Check for minification
    # ==========================================
    print(f"\n{YELLOW}[3/4] Checking for minified code...{RESET}")
    
    for file in source_files:
        try:
            with open(file, 'r', encoding='utf-8', errors='ignore') as f:
                lines = f.readlines()
        except:
            continue
        
        if not lines:
            continue
        
        total_lines = len(lines)
        long_lines = 0
        very_long_lines = 0
        semicolon_abuse = 0
        empty_lines = 0
        
        for line in lines:
            # Empty lines
            if re.match(r'^\s*$', line):
                empty_lines += 1
                continue
            
            # Line length
            line_len = len(line.rstrip('\n\r'))
            if line_len > 150:
                long_lines += 1
            if line_len > 300:
                very_long_lines += 1
            
            # Semicolon count (ignore strings and comments)
            clean_line = re.sub(r'//.*$', '', line)
            clean_line = re.sub(r'"[^"]*"', '""', clean_line)
            clean_line = re.sub(r"'[^']*'", "''", clean_line)
            
            semicolons = clean_line.count(';')
            
            # For loops naturally have 2 semicolons
            if re.search(r'\bfor\s*\(', line):
                if semicolons > 5:
                    semicolon_abuse += 1
            else:
                if semicolons > 3:
                    semicolon_abuse += 1
        
        # Calculate empty ratio
        empty_ratio = round((empty_lines / total_lines) * 100, 1) if total_lines > 0 else 0
        file_ok = True
        
        if long_lines > 5:
            print(f"  {RED}ERROR: {file.name} - {long_lines} lines over 150 chars [MINIFIED]{RESET}")
            has_error = True
            file_ok = False
        
        if very_long_lines > 0:
            print(f"  {RED}ERROR: {file.name} - {very_long_lines} lines over 300 chars [SEVERE]{RESET}")
            has_error = True
            file_ok = False
        
        if semicolon_abuse > 3:
            print(f"  {RED}ERROR: {file.name} - {semicolon_abuse} lines with excess semicolons [MINIFIED]{RESET}")
            has_error = True
            file_ok = False
        
        if total_lines > 50 and empty_ratio < 5:
            print(f"  {RED}ERROR: {file.name} - only {empty_ratio}% empty lines [MINIFIED]{RESET}")
            has_error = True
            file_ok = False
        
        if file_ok:
            print(f"  {GREEN}OK: {file.name} ({empty_ratio}% whitespace){RESET}")
    
    # ==========================================
    # PHASE 4: Check for obfuscation
    # ==========================================
    print(f"\n{YELLOW}[4/4] Checking for obfuscation...{RESET}")
    obfuscation_found = False
    
    for file in source_files:
        try:
            with open(file, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
        except:
            continue
        
        # Macro spam
        macros = len(re.findall(r'#define\s+\w+\s*\(', content))
        if macros > 30:
            print(f"  {YELLOW}WARNING: {file.name} - {macros} function macros{RESET}")
        
        # Comma operator abuse: (a=1,b=2,c=3,d=4)
        comma_abuse = len(re.findall(r'\([^()]*=[^()]*,[^()]*=[^()]*,[^()]*=[^()]*\)', content))
        if comma_abuse > 5:
            print(f"  {RED}ERROR: {file.name} - comma operator abuse{RESET}")
            has_error = True
            obfuscation_found = True
        
        # Nested ternary: a?b:c?d:e?f:g
        ternary_chains = len(re.findall(r'\?[^;]+\?[^;]+\?', content))
        if ternary_chains > 3:
            print(f"  {RED}ERROR: {file.name} - nested ternary abuse{RESET}")
            has_error = True
            obfuscation_found = True
        
        # Single letter variable spam
        single_vars = len(re.findall(r'\b(int|float|double|char|bool|auto)\s+[a-z]\s*[,;=]', content))
        if single_vars > 20:
            print(f"  {YELLOW}WARNING: {file.name} - {single_vars} single-letter vars{RESET}")
    
    if not obfuscation_found:
        print(f"  {GREEN}OK - No obfuscation detected{RESET}")
    
    # ==========================================
    # FINAL VERDICT
    # ==========================================
    print(f"\n========================================")
    
    if has_error:
        print(f"{RED}BUILD REFUSED - Code quality issues!{RESET}")
        print("========================================\n")
        print(f"{YELLOW}RULES:{RESET}")
        print("  - Max 500 lines per file")
        print("  - Max 150 chars per line")
        print("  - Max 3 semicolons per line")
        print("  - Min 5% empty lines")
        print("  - No numbered files (file_1, file_2)")
        print(f"\n{YELLOW}PROPER MODULES:{RESET}")
        print("  net.cpp player.cpp render.cpp")
        print("  audio.cpp world.cpp menu.cpp")
        print("  input.cpp utils.cpp")
        print(f"\n{CYAN}Each file = ONE responsibility!{RESET}")
        return 1
    
    print(f"{GREEN}All checks passed!{RESET}")
    print("========================================\n")
    
    # ==========================================
    # BUILD
    # ==========================================
    build_dir = script_dir / "build"
    build_dir.mkdir(exist_ok=True)
    
    print("Compiling...")
    
    cmd = [
        'g++',
        '-std=c++17', '-O2', '-Wall',
        '-Wno-unused-result', '-Wno-unknown-pragmas',
        '-mwindows', '-static', '-static-libgcc', '-static-libstdc++',
        '-I', str(script_dir / 'deps' / 'include'),
        '-o', str(build_dir / 'backrooms.exe'),
        str(src_dir / 'game.cpp'),
        str(script_dir / 'deps' / 'src' / 'glad.c'),
        '-L', str(script_dir / 'deps' / 'lib'),
        '-lglfw3', '-lopengl32', '-lgdi32', '-luser32',
        '-lkernel32', '-lwinmm', '-lws2_32'
    ]
    
    result = subprocess.run(cmd, capture_output=True, text=True)
    
    if result.returncode != 0:
        print(f"\n{RED}Build FAILED!{RESET}")
        if result.stderr:
            print(result.stderr)
        return 1
    
    print(f"\n{GREEN}========================================")
    print("Build successful!")
    print(f"========================================{RESET}")
    print("Run: build\\backrooms.exe")
    return 0

if __name__ == '__main__':
    sys.exit(main())